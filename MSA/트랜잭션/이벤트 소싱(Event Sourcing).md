# 이벤트 소싱(Event Sourcing)

## 1. 이벤트 소싱의 정의

이벤트 소싱은 애플리케이션의 상태 변화를 이벤트 시퀀스로 저장하는 패턴. 기존 데이터베이스가 현재 상태만 저장하는 것과 달리, 이벤트 소싱은 상태 변화를 일으킨 모든 이벤트를 시간 순서대로 기록. 현재 상태는 저장된 이벤트를 처음부터 순차적으로 적용해 계산.

## 2. 핵심 원칙

### 2.1 불변성(Immutability)
- 한번 저장된 이벤트는 절대 변경 불가능.
- 이벤트 저장소는 append-only 로그로 구현.
- 변경이 필요한 경우 보정 이벤트(compensating event) 추가.

### 2.2 이벤트 중심 설계
- 모든 상태 변경은 이벤트로 표현.
- 이벤트는 과거 시제로 명명(예: AccountCreated, FundsWithdrawn).
- 이벤트는 발생한 사실(fact)을 나타내며 의도가 명확히 드러남.

### 2.3 이벤트 재생(Event Replay)
- 저장된 이벤트를 순차적으로 적용해 어느 시점의 상태로든 재구성 가능.
- 시스템 장애 발생 시 이벤트 재생으로 상태 복구.
- 디버깅, 테스트, 감사에 활용 가능.

## 3. 이벤트 소싱 아키텍처 구성요소

### 3.1 이벤트 스토어(Event Store)
- 이벤트 저장 및 검색을 위한 특수 데이터베이스.
- 시간 순서대로 이벤트 저장 및 조회 기능 제공.
- 이벤트 스트림 구독 메커니즘 지원.
- 대표적 구현: EventStoreDB, Axon Server, Kafka + 데이터베이스 조합.

### 3.2 애그리게이트(Aggregate)
- 도메인 모델의 일관성 경계.
- 이벤트를 적용해 상태 변경을 관리.
- 명령(Command)을 처리하고 새 이벤트 생성.
- 이벤트 소싱에서는 상태 변경 로직과 이벤트 적용 로직을 명확히 분리.

### 3.3 프로젝션(Projection)
- 이벤트 스트림을 처리해 읽기 최적화된 뷰 모델 생성.
- 다양한 쿼리 요구사항에 맞춘 특화된 뷰 제공.
- CQRS 패턴과 함께 사용 시 강력한 쿼리 기능 제공.
- 필요시 실시간 또는 배치 처리로 뷰 모델 갱신.

### 3.4 스냅샷(Snapshot)
- 특정 시점의 애그리게이트 상태 저장.
- 전체 이벤트 재생 대신 스냅샷부터 재생으로 성능 최적화.
- 주기적 또는 이벤트 개수 기준으로 생성.
- 스냅샷 이후 발생한 이벤트만 로드하여 처리 속도 향상.

## 4. 구현 패턴

### 4.1 CQRS(Command Query Responsibility Segregation)와의 결합
- 명령(상태 변경)과 쿼리(상태 조회) 책임 분리.
- 명령 측: 이벤트 소싱으로 상태 변경 처리.
- 쿼리 측: 프로젝션을 통해 최적화된 읽기 모델 제공.
- 확장성과 성능 최적화에 유리.

### 4.2 이벤트 버저닝(Event Versioning)
- 시간이 지남에 따라 이벤트 스키마 변경 필요성 발생.
- 명시적 버전 관리로 이전 버전 이벤트 호환성 유지.
- 이벤트 업컨버터(Upcaster) 패턴으로 이전 버전 이벤트 변환.
- 스키마 레지스트리 활용 가능.

### 4.3 이벤트 소싱과 Saga 패턴
- 분산 트랜잭션 관리를 위한 Saga 패턴과 이벤트 소싱 결합.
- 이벤트가 다음 프로세스 단계 트리거.
- 실패 시 보상 이벤트로 롤백 처리.
- 복잡한 비즈니스 프로세스 추적 및 관리 용