# Saga 패턴 정리

## 1. 분산 트랜잭션의 특징성

### (1) 모놀리식에서의 트랜잭션 vs 마이크로서비스에서의 문제
- 모놀리식 애플리케이션에서는 ACID 트랜잭션으로 데이터 일관성 보장.
- 마이크로서비스에서는 서비스별 독립 데이터베이스로 인해 분산 트랜잭션 문제 발생.
- 2PC(Two-Phase Commit)는 성능 저하와 확장성 문제가 있음.

### (2) 2PC/XA 프로토콜 한계
- 모든 리소스가 준비될 때까지 잠금 유지로 성능 저하 발생.
- 코디네이터 장애 시 리소스 블로킹 문제 발생.
- 현대 클라우드 환경과 NoSQL 데이터베이스에서 지원 부족.

## 2. Saga 패턴의 개념과 필요성

### (1) 왜 Saga가 해결책인가?
- 긴 트랜잭션을 여러 개의 독립적인 로컬 트랜잭션으로 분할.
- 각 로컬 트랜잭션은 자체 서비스 내에서 완결.
- 최종 일관성(Eventual Consistency) 보장.

### (2) Saga의 작동 원리: 단계별 로컬 트랜잭션과 보상(Compensating) 트랜잭션
- 각 단계는 로컬 트랜잭션 수행 후 다음 단계 트리거.
- 실패 시 이전 단계의 트랜잭션을 보상 트랜잭션으로 롤백.
- 보상 트랜잭션은 실행된 트랜잭션의 역순으로 실행.

### (3) 일관성/격리 수준 예시, ACID와의 차이점(고립성 이슈)
- Saga는 ACID의 원자성(A)과 일관성(C)은 보장하나 격리성(I)은 완전히 보장하지 않음.
- 격리성 문제로 인한 이슈:
    - 더티 리드(Dirty Read): 다른 Saga가 미완료 트랜잭션 데이터 읽는 문제.
    - 데이터 덮어쓰기: 동시 Saga 실행 시 데이터 충돌 발생.

## 3. 오케스트레이션 기반 Saga

### (1) 중앙 중재형 Orchestrator와 Command/Reply
- 중앙 Orchestrator가 전체 Saga 흐름 조정.
- 각 서비스에 명령(Command) 전송, 응답(Reply) 수신.
- 실패 시 보상 트랜잭션 조정.

### (2) 오케스트레이션 기반의 장점과 단점
- 장점:
    - 중앙 집중식 관리로 복잡성 감소.
    - 의존성 명확화 및 이해 용이.
    - 구현 및 테스트 단순화.
- 단점:
    - 중앙 집중화로 인한 단일 장애점 위험.
    - 서비스 간 결합도 증가.
    - 오케스트레이터 비대화 가능성.

### (3) 오류 발생 시 보상 트랜잭션
- 특정 단계 실패 시 오케스트레이터가 보상 트랜잭션 순차적 실행.
- 성공한 트랜잭션만 선택적으로 보상 처리.
- 멱등성(Idempotence) 보장으로 재시도 안전성 확보.

## 4. 코레오그래피 기반 Saga

### (1) 이벤트 발행/구독 방식
- 각 서비스는 작업 완료 후 이벤트 발행.
- 다음 서비스는 이벤트 구독하여 자신의 트랜잭션 실행.
- 중앙 조정자 없이 이벤트 기반 통신.

### (2) Outbox 패턴 & 이벤트
- 로컬 데이터베이스 트랜잭션과 메시지 발행의 원자성 보장.
- 데이터 변경과 이벤트 발행을 단일 트랜잭션으로 처리.
- 이벤트 발행 안정성 확보.

### (3) 코레오그래피 장점/단점
- 장점:
    - 높은 자율성과 낮은 결합도.
    - 느슨한 결합으로 시스템 유연성 증가.
    - 서비스 확장성 향상.
- 단점:
    - 흐름 파악 어려움과 복잡성 증가.
    - 순환 의존성 발생 가능.
    - 디버깅과 모니터링 어려움.

## 5. 오케스트레이션 vs 코레오그래피: 사가(Saga) 관점에서의 비교
- 오케스트레이션: 중앙 집중적, 명확한 흐름, 높은 제어성.
- 코레오그래피: 분산형, 높은 자율성, 느슨한 결합.
- 복잡도와 규모에 따라 적합한 방식 선택 필요.

## 6. 오케스트레이션 vs 코레오그래피: 마이크로서비스 협업 모델 전반에서의 적용

### 6.1 일반적인 개요
- (1) 오케스트레이션:
    - 중앙 조정자 주도 프로세스 흐름.
    - API Gateway, BPM 도구 등으로 구현.
    - 상태 추적 용이, 가시성 높음.

- (2) 코레오그래피:
    - 이벤트 기반 협업 모델.
    - 이벤트 브로커(Kafka, RabbitMQ 등) 활용.
    - 자율적 서비스 동작, 느슨한 결합.

### 6.2 Netflix Conductor 동작 사례
- 워크플로우 정의 및 실행 엔진 제공.
- JSON 기반 워크플로우 정의로 복잡한 프로세스 관리.
- 재시도, 롤백, 타임아웃 정책 관리 기능 제공.

### 6.3 Orchestration의 장점
- 비즈니스 프로세스 가시성 확보.
- 중앙 집중식 오류 처리 및 재시도 관리.
- 복잡한 워크플로우 관리 용이.

### 6.4 Orchestration의 한계
- 중앙 의존성으로 인한 확장성 제약.
- 단일 장애점(SPOF) 위험.
- 서비스 자율성 감소 가능성.