# DB 복제 지연의 이해와 해결방법

## 복제 지연이란?

복제 지연은 데이터가 쓰기 DB에서 읽기 DB로 복제되는 과정에서 발생하는 시간 지연을 의미한다. 이 용어는 쓰기 작업이 발생한 후 그 변경 사항이 읽기 DB에 반영되기까지의 지연 시간을 설명하는 데 사용된다.

복제 지연으로 인해, 읽기 DB에서 최신 상태의 데이터를 읽지 못하고 이전 상태의 데이터를 읽게 되는 문제가 발생할 수 있다.

시스템에서는 일반적으로 다음과 같은 방식으로 데이터베이스를 운영한다:

- **쓰기 DB**: 모든 쓰기 작업(데이터 삽입, 업데이트, 삭제 등)을 처리하는 데이터베이스다. 보통 마스터(master) 데이터베이스라고도 한다.
- **읽기 DB**: 읽기 작업만 처리하는 데이터베이스로, 보통 슬레이브(slave) 데이터베이스 또는 리플리카(replica)라고 한다. 이 데이터베이스는 쓰기 DB에서 복제(replication)된 데이터를 사용한다.

## 문제 발생 예시

쓰기와 읽기 DB가 분리된 시스템에서는 쓰기 작업이 일어난 후, 그 변경 내용이 읽기 DB로 복제되기까지 시간이 걸린다. 이 지연으로 인해 다음과 같은 상황이 발생할 수 있다:

1. **쓰기 작업**: 애플리케이션이 쓰기 DB에 새로운 데이터를 저장한다.
2. **지연**: 이 데이터는 복제 지연 때문에 즉시 읽기 DB에 반영되지 않는다.
3. **읽기 작업**: 쓰기 작업 직후에 애플리케이션이 읽기 DB에서 데이터를 조회하려고 한다.
4. **이전 데이터 조회**: 이 시점에서 읽기 DB는 아직 새로운 데이터를 반영하지 않았기 때문에, 이전 데이터를 반환할 수 있다.


## 해결 방법

### 지연 적용 알고리즘 (Lag Compensating Logic)

쓰기 후 즉시 읽기를 시도하는 경우, 잠시 지연을 두고 읽기를 재시도하는 방법이다. 지연된 시간만큼의 시간이 지나면, 대부분의 경우 읽기 DB가 최신 데이터를 반영하게 된다.

```java
public Product getProductAfterUpdate(Long productId) {
    // 지연 시간(밀리초)
    int delay = 500;
    
    try {
        // 쓰기 작업 후 지연
        Thread.sleep(delay);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    
    // 지연 후 읽기 DB에서 조회
    return productRepository.findById(productId).orElse(null);
}
```

### 쓰기 DB로의 직접 읽기 (Read-after-Write)

중요한 데이터에 대해 쓰기 직후 즉시 읽어야 하는 경우, 해당 읽기 작업을 쓰기 DB에서 직접 수행하도록 한다. 이를 통해 최신 데이터를 즉시 읽어올 수 있다.

```java
@Service
public class ProductService {
    
    @Autowired
    private MasterDataSource masterDataSource;
    
    @Autowired
    private SlaveDataSource slaveDataSource;
    
    @Transactional(readOnly = false)
    public Product updateProduct(Product product) {
        // 쓰기 DB에 업데이트
        return masterDataSource.update(product);
    }
    
    @Transactional(readOnly = true)
    public Product getProductById(Long id, boolean forceConsistentRead) {
        if (forceConsistentRead) {
            // 일관성이 중요한 경우 마스터 DB에서 직접 읽기
            return masterDataSource.findById(id);
        } else {
            // 일반적인 경우 읽기 DB에서 조회
            return slaveDataSource.findById(id);
        }
    }
}
```

### 읽기 DB와 쓰기 DB 간의 복제 지연 최소화

복제 지연을 최소화하도록 데이터베이스 설정을 조정할 수 있다. 예를 들어, MySQL의 경우 복제 지연을 줄이기 위해 semi-synchronous replication을 사용하거나, 다른 복제 설정을 최적화할 수 있다.

```properties
# MySQL의 semi-synchronous replication 설정 예시
rpl_semi_sync_master_enabled = 1
rpl_semi_sync_master_timeout = 10000  # 10초
rpl_semi_sync_slave_enabled = 1
```

그러나 물리적인 네트워크 지연이나 시스템 부하 등으로 인해 지연을 완전히 제거할 수는 없다.

### CQRS 패턴

Command Query Responsibility Segregation (CQRS) 패턴을 적용하여, 쓰기 작업과 읽기 작업을 명확히 분리하고, 읽기 작업에 대해 일관성을 보장하는 별도의 메커니즘을 적용할 수 있다.

예를 들어, 쓰기 DB의 변경이 읽기 DB에 완전히 반영된 후에야 읽기 작업을 허용하는 방식을 도입할 수 있다.

```java
@Service
public class CQRSProductService {
    
    @Autowired
    private CommandHandler commandHandler;
    
    @Autowired
    private QueryHandler queryHandler;
    
    public void updateProduct(UpdateProductCommand command) {
        // 명령 처리 (쓰기 작업)
        commandHandler.handle(command);
        
        // 이벤트 발행 (복제 완료 알림을 위한)
        eventPublisher.publishEvent(new ProductUpdatedEvent(command.getProductId()));
    }
    
    public ProductDTO getProduct(Long productId) {
        // 쿼리 처리 (읽기 작업)
        return queryHandler.getProduct(productId);
    }
}
```

### 캐시 사용

캐시 시스템을 도입하여, 쓰기 작업 후 바로 캐시를 갱신하고, 그 이후의 읽기 작업은 캐시에서 제공하는 방식을 사용한다. 캐시는 일관성을 보장하기 위해 일정 시간 동안(예: 1초) 쓰기 DB의 데이터를 캐시하는 방법을 사용할 수 있다.

```java
@Service
public class ProductService {
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        return productRepository.findById(id).orElse(null);
    }
    
    @CachePut(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        // 실제 데이터베이스 업데이트 로직
        Product updatedProduct = productRepository.save(product);
        return updatedProduct;
    }
}
```

## 결론

복제 지연은 분산 데이터베이스 시스템에서 불가피하게 발생할 수 있는 문제다. 이를 완전히 제거하기는 어렵지만, 위에서 설명한 방법들을 통해 그 영향을 최소화하고 사용자 경험을 향상시킬 수 있다. 비즈니스 요구사항과 시스템 특성에 맞게 적절한 방법을 선택하여 적용하는 것이 중요하다.